// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

/// Referral status to track review and reward outcomes without exposing limits to users
enum ReferralStatus {
    PENDING
    APPROVED
    REJECTED
}

/// Video job processing status
enum VideoJobStatus {
    QUEUED
    PROCESSING
    COMPLETED
    FAILED
}

/// Which provider handles avatar video generation; start with MOCK
enum VideoProvider {
    MOCK
}

model User {
    id           String   @id @default(cuid())
    createdAt    DateTime @default(now())
    email        String?  @unique
    phone        String?
    passwordHash String?
    name         String?
    locale       String?
    country      String?

    /// Hashed, anonymized identifiers for anti-abuse checks
    fingerprintHash String?
    ipHash          String?

    referralCodes          ReferralCode[]
    referralEvents         ReferralEvent[] @relation("UserReferralEvents")
    referredEventsReceived ReferralEvent[] @relation("ReferredUserEvents")
    videoJobs              VideoJob[]
    videos                 Video[]

    accounts Account[]
    sessions Session[]

    subscriptions   Subscription[]
    manualPayments  ManualPayment[]
    contactMessages ContactMessage[]

    @@index([fingerprintHash])
    @@index([ipHash])
}

model ManualPayment {
    id          String   @id @default(cuid())
    userId      String
    user        User     @relation(fields: [userId], references: [id])
    createdAt   DateTime @default(now())
    status      String   @default("PENDING") // PENDING, APPROVED, REJECTED
    amountCents Int
    currency    String   @default("USD")
    note        String?
    receiptUrl  String?

    @@index([userId])
}

model ContactMessage {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    name      String?
    email     String
    message   String
    userId    String?
    user      User?    @relation(fields: [userId], references: [id])

    // Ticket system fields
    status   String @default("PENDING") // PENDING, IN_PROGRESS, RESOLVED, CLOSED
    priority String @default("MEDIUM") // LOW, MEDIUM, HIGH, URGENT
    category String @default("GENERAL") // TECHNICAL, BILLING, FEATURE_REQUEST, BUG_REPORT, GENERAL

    @@index([userId])
    @@index([status])
    @@index([priority])
    @@index([category])
}

enum PlanTier {
    BASIC
    STANDARD
    PREMIUM
}

enum SubscriptionStatus {
    ACTIVE
    CANCELED
    EXPIRED
}

model Subscription {
    id        String   @id @default(cuid())
    userId    String
    user      User     @relation(fields: [userId], references: [id])
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    tier               PlanTier
    status             SubscriptionStatus @default(ACTIVE)
    currentPeriodStart DateTime
    currentPeriodEnd   DateTime

    cancelAtPeriodEnd Boolean @default(false)

    @@index([userId])
}

/// NextAuth adapter models
model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? @map("refresh_token")
    access_token      String? @map("access_token")
    expires_at        Int?    @map("expires_at")
    token_type        String? @map("token_type")
    scope             String?
    id_token          String? @map("id_token")
    session_state     String? @map("session_state")

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
    @@index([userId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    rememberMe   Boolean  @default(false)

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

model ReferralCode {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    code      String   @unique

    ownerId String
    owner   User   @relation(fields: [ownerId], references: [id])

    /// Hidden caps enforced server-side (not returned to clients)
    maxRewardsTotal Int? // total rewards cap per code
    dailyCap        Int? // daily redemption cap

    events ReferralEvent[]

    @@index([ownerId])
}

model ReferralEvent {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())

    /// The referrer who owns the code
    referrerId String
    referrer   User   @relation("UserReferralEvents", fields: [referrerId], references: [id])

    /// Optional user record for the referred account if/when itâ€™s created
    referredUserId String?
    referredUser   User?   @relation("ReferredUserEvents", fields: [referredUserId], references: [id])

    /// The code used
    referralCodeId String
    referralCode   ReferralCode @relation(fields: [referralCodeId], references: [id])

    /// Anti-abuse signals (hashed, never store raw PII)
    referredFingerprintHash String?
    referredIpHash          String?
    userAgent               String?

    status        ReferralStatus @default(PENDING)
    rewardGranted Int            @default(0)
    reviewReason  String?

    @@index([referrerId])
    @@index([referralCodeId])
    @@index([referredFingerprintHash])
    @@index([referredIpHash])
}

model VideoJob {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    userId String?
    user   User?   @relation(fields: [userId], references: [id])

    provider      VideoProvider @default(MOCK)
    providerJobId String?

    status   VideoJobStatus @default(QUEUED)
    videoUrl String?

    /// Video metadata
    title        String?
    description  String?
    duration     Int? // duration in seconds
    thumbnailUrl String?
    fileSize     Int? // file size in bytes
    resolution   String? // e.g., "1920x1080"
    format       String? // e.g., "MP4"
    quality      String? // e.g., "HD", "4K"

    /// Analytics
    views     Int @default(0)
    downloads Int @default(0)

    /// Inputs
    script              String
    backgroundImageUrls Json // 2-4 URLs
    productImageUrls    Json // array of product/device/food URLs
    contactAddress      String?
    contactPhone        String?
    logoImageUrl        String? // company logo overlay (subtle corner)

    /// Optional publishing meta (for regional scheduling)
    publishRegion      String?
    publishAtTikTok    DateTime?
    publishAtInstagram DateTime?

    scheduledPosts ScheduledPost[]

    @@index([userId])
}

/// Scheduled posts for social media publishing
model ScheduledPost {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    videoJobId String
    videoJob   VideoJob @relation(fields: [videoJobId], references: [id])

    socialNetwork String // youtube, instagram, tiktok, facebook, twitter, linkedin
    scheduledDate DateTime
    status        String   @default("SCHEDULED") // SCHEDULED, PUBLISHED, FAILED, CANCELLED
    customMessage String?

    @@index([videoJobId])
    @@index([socialNetwork])
    @@index([scheduledDate])
}

/// Generated videos
model Video {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    userId String
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

    title       String
    status      String    @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
    videoUrl    String?
    completedAt DateTime?

    /// Video generation settings
    settings Json // avatar, language, background, text, quality, format

    @@index([userId])
    @@index([status])
    @@index([createdAt])
}
